#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#include "MT19937_rand.h"

static uint16_t real_seed;
static int is_real_token;

static void init_stream(uint16_t seed)
{
	MT19937_srand(seed);
}

static uint8_t stream_byte()
{
	return MT19937_rand() & 0xFF;
}

static void encrypt(uint8_t *ciphertext, const uint8_t *plaintext, size_t len, uint16_t seed)
{
	size_t i;

	init_stream(seed);

	for (i = 0; i < len; i++)
		ciphertext[i] = plaintext[i] ^ stream_byte();
}

static void decrypt(uint8_t *plaintext, const uint8_t *ciphertext, size_t len, uint16_t seed)
{
	size_t i;

	init_stream(seed);

	for (i = 0; i < len; i++)
		plaintext[i] = ciphertext[i] ^ stream_byte();
}

uint8_t *get_ciphertext(size_t *clen, const uint8_t *known_plaintext, size_t len)
{
	uint16_t seed;
	uint8_t *modified_plaintext;
	uint8_t *ciphertext;
	size_t prefix_len;
	size_t i;

	prefix_len = rand() % 10;
	modified_plaintext = malloc(prefix_len + len);

	if (modified_plaintext == NULL)
		return NULL;

	ciphertext = malloc(prefix_len + len);

	if (ciphertext == NULL) {
		free(modified_plaintext);
		return NULL;
	}

	for (i = 0; i < prefix_len; i++)
		modified_plaintext[i] = rand() & 0xFF;

	memcpy(modified_plaintext + prefix_len, known_plaintext, len);

	seed = time(NULL);
	encrypt(ciphertext, modified_plaintext, prefix_len + len, seed);

	free(modified_plaintext);
	real_seed = seed;

	*clen = prefix_len + len;
	return ciphertext;
}

uint16_t crack_seed(const uint8_t *ciphertext, size_t clen, const uint8_t *known_plaintext, size_t plen)
{
	uint16_t seed;
	uint8_t *cipher, *modified_plaintext;
	uint32_t i;

	cipher = malloc(clen);
	modified_plaintext = malloc(clen);
	memcpy(modified_plaintext + clen - plen, known_plaintext, plen);

	for (i = 0; i < 0x10000; i++) {
		seed = (uint16_t)i;
		encrypt(cipher, modified_plaintext, clen, seed);

		if (memcmp(cipher + clen - plen, ciphertext + clen - plen, plen) == 0)
			break;
	}

	return seed;
}

void get_token(uint8_t *token, size_t len)
{
	size_t i;

	if (rand() % 2 == 0) {
		MT19937_srand((time(NULL)) & 0xffff);

		for (i = 0; i < len; i++)
			token[i] = MT19937_rand() & 0xFF;

		is_real_token = 1;
	} else {
		for (i = 0; i < len; i++)
			token[i] = rand() & 0xFF;

		is_real_token = 0;
	}
}

int is_valid_token(const uint8_t *token, size_t len)
{
	uint16_t seed;
	size_t i, j;
	int same;

	for (i = 0; i < 0x10000; i++) {
		seed = (uint16_t)i;
		MT19937_srand(seed);
		same = 1;

		for (j = 0; j < len; j++) {
			if ((MT19937_rand() & 0xFF) != token[j]) {
				same = 0;
				break;
			}
		}

		if (same == 1)
			return 1;
	}

	return 0;
}

int main()
{
	const uint8_t *known_plaintext = "AAAAAAAAAAAAAA";
	uint8_t token[10];
	uint8_t *ciphertext;
	size_t clen;
	uint16_t seed;
	int i, errors;

	srand(time(NULL));
	ciphertext = get_ciphertext(&clen, known_plaintext, 14);
	seed = crack_seed(ciphertext, clen, known_plaintext, strlen(known_plaintext));

	printf("Seed: 0x%04x\n", seed);
	printf("Real seed: 0x%04x\n", real_seed);

	free(ciphertext);
	errors = 0;

	for (i = 0; i < 10; i++) {
		get_token(token, sizeof token);

		if (is_valid_token(token, sizeof token) != is_real_token)
			++errors;
	}

	printf("Errors in detecting password reset tokens generated by MT19937 PRNG: %d / 10\n", errors);
	return 0;
}
